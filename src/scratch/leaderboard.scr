Events:
    UpdateLeaderboard
Globals:
    g:Leaderboard_Name
    g:Leaderboard_Score
Cloud:
    c:Leaderboard1
    c:Leaderboard2
Local Const:
    MAX_SCORES = 100
    // Note: These 2 set by init_chs
    CH_0 = <char index of '0'>
    CH_9 = <char index of '9'>
    // Note: This one set after initialization of char array.
    MAX_C = length of chs
    CH_STR // used for initialization of chs only
    
Local:
    chs[]  // list of chars with offset corresponding to encoding
    lbs[]
    try[]
    cis[]
    css[]
    ary[]
    flens[]
    isnum[]
    idx
    wr_idx
    done
    i
    j
    ii
    n
    nn
    c      // generic char var
    s      // generic string var
    cs     // generic cksum var
    enc    // updated and encoded leaderboard
Function Local:
    enc_c
    enc_i
    enc_cs
    enc_enc
Function Local:
    encall_enc
Function Local:
    dec_i
    dec_c
    dec_ci
    dec_n
    dec_nf
    dec_fi
    dec_flen
    dec_s
    dec_cs

On Start:
    // TODO: Perhaps lazy init.
    init_chs // in scratch only, but pretty simple
    MAX_C = length of chs
    flens = [50, 500, 50]
    isnum = [1, 0, 1]
    
On UpdateLeaderboard:
    lbs = [c:Leaderboard1, c:Leaderboard2]
    try = [] // potentially-valid lb indices
    cis = [] // holds cidx value for next call to dec
    css = []
    // Partially process both lbs.
    i = 1
    repeat 2
        ii = i * 2 - 1
        // Pre-validation
        // Encoded string must have at least 2-digits each of cs, sep, sn, and
        // all digits must appear in pairs.
        // TODO: Min could be more than 6 if we have a seqno bias.
        n = length of lbs[i]
        if n < 6 || (n + 1) mod 2 = 0
            dec_ok = false
        else
            dec(lbs[i], 1, 1, 1, 2, 2)
        // Add unconditionally (regardless of validity) to assure proper length.
        add dec_cidx to cis
        add dec_cs to css
        if dec_ok
            // Validate cs and sn
            // TODO: Perhaps more checking on (eg) seqno
            if ary[ii] > 0 && ary[ii+1] > 0
                // Insert at proper location in try[]
                // Note: With only 2 elements, sorted add is simple.
                if length of try = 0 || try[1] > ary[ii+1]
                    add i to try[] // append
                else
                    insert i at 1 in try
        i++

    idx = 0 // will be set to point to first valid lb (if any)
    // Try all potentially-valid lbs
    i = 1
    n = length of try
    repeat until done || i > n
        j = try[i]
        dec(lbs[j], cis[j], 2, 3, 0, 0)
        if dec_ok
            ii = j * 2 - 1 // index of cs in ary
            if ary[ii] = css[j] + dec_cs
                done = true
                idx = j
                // Trim ary if necessary.
                if dec_fcnt + 2 < length of ary
                    trunc_ary dec_fcnt + 2
        i++

    if idx > 0
        // At least 1 lb valid
        // Remove unused elements from ary[].
        wr_idx = (idx mod 2) + 1
        repeat 2
            delete wr_idx * 2 - 1 of ary
    else
        delete all of ary
        add 0 to ary // to be filled in later
        // Design Decision: Initialize seqno to bolster checksum.
        add 1234 to ary
        wr_idx = 1
    
    // Insert current user's name/score
    ins(g:Leaderboard_Name, g:Leaderboard_Score)

    // Encode everything in ary.
    encall

    // Write back to appropriate cloud var.
    if wr_idx = 1
        c:Leaderboard1 = encall_enc
    else
        c:Leaderboard2 = encall_enc

Block: trunc_ary(keep)
    repeat (length of ary) - keep
        delete last of ary

// Inputs: lb, cidx, f1, f2, min_nf, max_nf
// Outputs: dec_ok, dec_ci, dec_fcnt, dec_cs
Block: dec(lb, ci, f1, f2, min_nf, max_nf)
    dec_ci = ci
    dec_n = length of lb
    dec_nf = 0           // # flds processed
    dec_fi = f1          // cur fld in ary (wraps at f2)
    dec_flen = 0         // fld len
    dec_s = ''           // fld accum
    dec_cs = 0
    dec_ok = true

    repeat until dec_ci > dec_n || not dec_ok
        if dec_n - dec_ci < 1
            // TODO: Odd # of digits - just check this up front.
            dec_ok = false
        // Get and validate next pair of digits.
        dec_c = ''
        dec_i = 1
        repeat until dec_i > 2 || not dec_ok
            if lb[dec_ci] < CH_0 || lb[dec_ci] > CH_9
                dec_ok = false
            else
                dec_c = join(dec_c, lb[dec_ci])
            dec_i++
            dec_ci++

        if dec_c > 0
            // Note: Increment dec_flen here so it can be used in validation.
            dec_flen++
            dec_cs += dec_c
            // Validation
            if dec_flen > flens[dec_fi]
                // Field too long!
                dec_ok = false
            else
                if dec_c > MAX_C
                    // Bad char!
                    dec_ok = false
                else
                    // Decode a single character.
                    dec_s = join(dec_s, letter dec_c of chs)
                    // TODO: Consider doing digit check here, in lieu of (or in
                    // addition to) num check at field termination.
        else
            if dec_c = 0
                // Terminator found.
                // Fld validation
                if dec_flen = 0
                    dec_ok = false
                else
                    if isnum[dec_fi] && !(round(dec_s) = dec_s)
                        // Number required
                        dec_ok = false
                if dec_ok
                    // Fld complete
                    // Note: None of this matters if not dec_ok
                    add dec_s to ary
                    dec_nf++
                    dec_s = ''
                    dec_flen = 0
                    dec_fi++
                    if dec_fi > f2
                        dec_fi = f1

    // Final validation
    if dec_ok
        if dec_flen > 0
            // All fields must be terminated
            dec_ok = false
        else
            if dec_nf < min_nf
                dec_ok = false
            else
                if max_nf > 0 && dec_nf > max_nf
                    dec_ok = false
                else
                    if dec_fi > f1
                        // Must process whole number of f1..f2 chunks.
                        // Note: Could have arg that governs this...
                        dec_ok = false
            

// Context: Top-level
// Assumption: ary contains cs, sn, [NAME, SCORE]...
Block: ins(name, score)
    n = length of ary
    i = 3
    // Add name/score to sorted list and remove lowest scores when over limit.
    loop until i > n || done
        if !score < ary[i + 1]
            // Found spot!
            insert score at i in ary
            insert name at i in ary
            done = true
        i += 2
    // Calculate excess scores
    nn = (n - 2) / 2 - MAX_SCORES
    // Should we append current user's score?
    if !done && nn < 0
        add name to ary
        add score to ary
    // Delete lowest excess scores.
    // Assumption: repeat can handle neg. counts (tested).
    if nn > 0
        repeat n - (MAX_SCORES * 2)
            delete last of ary
    
// Outputs: enc_enc, enc_cs
Block: enc(str)
    enc_i = 1
    enc_cs = 0
    enc_enc = ''
    repeat length of str
        indexof(str[enc_i])
        enc_c = indexof_res
        // TODO: Perhaps check for 0, but shouldn't be able to happen.
        enc_cs += enc_c
        // Prepend leading '0' if necessary to ensure 2 digits.
        if length of enc_c = 1
            enc_c = join 0, enc_c
        enc_enc = join enc_enc, enc_c
        enc_i++
        

// Context: Top-level
// Outputs: encall_enc
Block: encall
    // TODO: Consider adding a bias to cs.
    cs = 0
    n = length of ary
    encall_enc = '00'
    
    // Encode all fields but cs, keeping up with cksum val as we go.
    i = 2
    repeat until i > n
        enc(ary[i])
        encall_enc = join encall_enc, join(enc_enc, '00')
        cs += enc_cs
        i++
    
    // Now prepend cs
    encall_enc(cs)
    encall_enc = join enc_enc, encall_enc
    

// TODO: The array chs may not longer be required, as we can loop over the
// string just as easily.
Block: init_chs
    ch_str = <ascii 0x20 .. 0x7e>
    i = 1
    delete all of chs
    repeat length of ch_str
        ltr = letter i of ch_str
        if ltr = 0
            CH_0 = i
        else
            if ltr = 9
                CH_9 = i
        add ltr to chs
        i++
    MAX_C = i - 1

Block: indexof(c)
    indexof_n = length of ch_str
    indexof_i = 1
    indexof_res = 0
    repeat until indexof_i > indexof_n || indexof_res > 0
        if (letter indexof_i of ch_str) = c
            indexof_res = indexof_i
        indexof_i++

// vim:ts=4:sw=4:et:ft=c
