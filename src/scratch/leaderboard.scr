Events:
    UpdateLeaderboard
Globals:
    g:Leaderboard_Name
    g:Leaderboard_Score
Cloud:
    c:Leaderboard1
    c:Leaderboard2
Local Const:
    MAX_SCORES = 100
    // Note: This one set after initialization of char array.
    MAX_C = length of chs
    CH_STR // used for initialization of chs only
    
Local:
    chs[]  // list of chars with offset corresponding to encoding
    lbs[]
    try[]
    cis[]
    ary[]
    flens[]
    isnum[]
    idx
    wr_idx
    done
    i
    j
    ii
    n
    nn
    c      // generic char var
    s      // generic string var
    cs     // generic cksum var
    enc    // updated and encoded leaderboard
Function Local:
    enc_cs
    enc_enc
Function Local:
    encall_enc
Function Local:
    dec_ci
    dec_n
    dec_nf
    dec_fi
    dec_flen
    dec_s
    dec_cs

On Start:
    // TODO: Perhaps lazy init.
    init_chs // in scratch only, but pretty simple
    MAX_C = length of chs
    flens = [50, 500, 50]
    isnum = [1, 0, 1]
    
On UpdateLeaderboard:
    lbs = [c:Leaderboard1, c:Leaderboard2]
    try = [] // potentially-valid lb indices
    cis = [] // holds cidx value for next call to dec
    // Partially process both lbs.
    i = 1
    repeat 2
        ii = i * 2 - 1
        dec(lbs[i], 1, 1, 1, 2, 2)
        // Add unconditionally (regardless of validity) to assure proper length.
        add dec_cidx to cis
        if dec_ok
            // Validate cs and sn
            // TODO: Perhaps more checking on (eg) seqno
            if ary[ii] > 0 && ary[ii+1] > 0
                add i to try[]
        i++

    idx = 0 // will be set to point to first valid lb
    // Try all potentially-valid lbs
    i = 1
    n = length of try
    repeat until done || i > n
        j = try[i]
        dec(lbs[j], cis[j], 2, 3, 0, 0)
        if dec_ok
            ii = j * 2 - 1 // index of cs in ary
            if ary[ii] = ary[ii + 1] + dec_cs
                done = true
                idx = j
                // Trim ary if necessary.
                if dec_fcnt + 2 < length of ary
                    trunc_ary dec_fcnt + 2
        i++

    if idx > 0
        // At least 1 lb valid
        // Remove unused elements from ary[].
        wr_idx = (idx mod 2) + 1
        repeat 2
            delete wr_idx * 2 - 1 of ary
    else
        delete all of ary
        add 0 to ary // to be filled in later
        // Design Decision: Initialize seqno to bolster checksum.
        add 1234 to ary
        wr_idx = 1
    
    // Insert current user's name/score
    ins(g:Leaderboard_Name, g:Leaderboard_Score)

    // Encode everything in ary.
    encall

    // Write back to appropriate cloud var.
    if wr_idx = 1
        c:Leaderboard1 = encall_enc
    else
        c:Leaderboard2 = encall_enc

Block: trunc_ary(keep)
    repeat (length of ary) - keep
        delete last of ary

// Inputs: lb, cidx, f1, f2, min_nf, max_nf
// Outputs: dec_ok, dec_ci, dec_fcnt, dec_cs
Block: dec(lb, ci, f1, f2, min_nf, max_nf)
    dec_ci = ci
    dec_n = length of lb
    dec_nf = 0           // # flds processed
    dec_fi = f1          // cur fld in ary (wraps at f2)
    dec_flen = 0         // fld len
    dec_s = ''           // fld accum
    dec_cs = 0
    dec_ok = true

    repeat until dec_ci > dec_n || not dec_ok
        c = join lb[dec_ci], lb[dec_ci + 1]
        dec_ci += 2

        if c > 0
            // Note: Increment dec_flen here so it can be used in validation.
            dec_flen++
            dec_cs += c
            // Validation
            if dec_flen > flens[dec_fi]
                // Field too long!
                dec_ok = false
            else
                if c > MAX_C
                    // Bad char!
                    dec_ok = false
                else
                    // Decode a single character.
                    dec_s = join(dec_s, letter c of chs)
                    // TODO: Consider doing digit check here, in lieu of (or in
                    // addition to) num check at field termination.
        else
            if c = 0
                // Terminator found.
                // Fld validation
                if dec_flen = 0
                    dec_ok = false
                else
                    if isnum[dec_fi] && !(round(dec_s) = dec_s)
                        // Number required
                        dec_ok = false
                if dec_ok
                    add dec_s to ary
                    // Fld complete
                    // Note: None of this matters if not dec_ok
                    dec_nf++
                    dec_s = ''
                    dec_flen = 0
                    dec_fi++
                    if dec_fi > f2
                        dec_fi = f1
            else
                dec_ok = false

    // Final validation
    if dec_ok
        if dec_flen > 0
            // All fields must be terminated
            dec_ok = false
        else
            if dec_nf < min_nf
                dec_ok = false
            else
                if max_nf > 0 && dec_nf > max_nf
                    dec_ok = false
                else
                    if dec_fi > f1
                        // Must process whole number of f1..f2 chunks.
                        // Note: Could have arg that governs this...
                        dec_ok = false
            

// Context: non-reentrant
// Assumption: ary contains cs, sn, [NAME, SCORE]...
Block: ins(name, score)
    n = length of ary
    i = 3
    // Add name/score to sorted list and remove lowest scores when over limit.
    loop until i > n || done
        if !score < ary[i + 1]
            // Found spot!
            insert score at i in ary
            insert name at i in ary
            done = true
        i += 2
    // Calculate excess scores
    nn = (n - 2) / 2 - MAX_SCORES
    // Should we append current user's score?
    if !done && nn < 0
        add name to ary
        add score to ary
    // Delete lowest excess scores.
    // Assumption: repeat can handle neg. counts (tested).
    if nn > 0
        repeat n - (MAX_SCORES * 2)
            delete last of ary
    
// Context: non-reentrant
// Outputs: enc_enc, enc_cs
Block: enc(str)
    i = 1
    enc_cs = 0
    enc_enc = ''
    repeat length of str
        index_of(str[i])
        c = index_of_res
        // TODO: Perhaps check for 0, but shouldn't be able to happen.
        cs += c
        // Prepend leading '0' if necessary to ensure 2 digits.
        if length of c = 1
            c = join 0, c
        enc_enc = join enc_enc, c
        i++
        

// Context: non-reentrant
// Outputs: encall_enc
Block: encall
    // TODO: Consider adding a bias to cs.
    cs = 0
    n = length of names
    encall_enc = '00'
    
    // Encode all fields but cs, keeping up with cksum val as we go.
    i = 2
    repeat until i > n
        encall_enc(ary[i])
        encall_enc = join encall_enc, enc_enc
        encall_enc = join encall_enc, '00'
        cs += enc_cs
        i++
    
    // Now prepend cs
    encall_enc(cs)
    encall_enc = join enc_enc, encall_enc
    


// vim:ts=4:sw=4:et:ft=c
